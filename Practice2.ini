import xml.etree.ElementTree as ET
import os
import sys
from urllib.parse import urlparse
import urllib.request
import tarfile
import io
from typing import Dict, List, Set, Tuple


class Config:
    def __init__(self, filename="config.xml"):
        self.filename = filename
        self.package_name = None
        self.repository_path = None
        self.mode = "test"
        self.max_depth = 3

    def load(self):
        if not os.path.exists(self.filename):
            raise FileNotFoundError(f"Файл конфигурации '{self.filename}' не найден.")

        tree = ET.parse(self.filename)
        root = tree.getroot()

        self.package_name = (root.findtext("package_name") or "").strip()
        self.repository_path = (root.findtext("repository_url") or "").strip()
        self.mode = (root.findtext("mode") or "test").strip().lower()
        self.max_depth = int(root.findtext("max_depth") or "3")

        if not self.package_name:
            raise ValueError("Параметр 'package_name' не задан.")
        if not self.repository_path:
            raise ValueError("Параметр 'repository_url' (или путь к тестовому файлу) не указан.")
        if self.max_depth <= 0:
            raise ValueError("max_depth должен быть положительным числом.")

    def display(self):
        print("   Конфигурация ")
        print(f"Пакет: {self.package_name}")
        print(f"Репозиторий/Файл: {self.repository_path}")
        print(f"Режим: {self.mode}")
        print(f"Максимальная глубина: {self.max_depth}")


class DependencyGraph:
    def __init__(self, max_depth: int):
        self.graph: Dict[str, List[str]] = {}
        self.max_depth = max_depth

    def load_from_test_file(self, path: str):
        if not os.path.exists(path):
            raise FileNotFoundError(f"Файл тестового репозитория '{path}' не найден.")
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line or ":" not in line:
                    continue
                pkg, deps = line.split(":", 1)
                pkg = pkg.strip()
                dep_list = deps.strip().split() if deps.strip() else []
                self.graph[pkg] = dep_list

    def dfs(self, package: str, depth: int, visited: Set[str], stack: Set[str], result: List[Tuple[str, str]]):
        if depth >= self.max_depth:
            return
        if package not in self.graph:
            return

        stack.add(package)

        for dep in self.graph[package]:
            result.append((package, dep))
            if dep in stack:
                print(f"Цикл: {dep} уже встречен в пути ({' → '.join(stack)})")
                continue
            if dep not in visited:
                self.dfs(dep, depth + 1, visited, stack, result)

        stack.remove(package)
        visited.add(package)

    def print_ascii_tree(self, package: str, depth=0, visited=None):
        """Печать зависимостей в виде ASCII-дерева"""
        if visited is None:
            visited = set()

        indent = "  " * depth
        print(f"{indent}- {package}")

        if depth + 1 >= self.max_depth:
            if self.graph.get(package):
                print(f"{indent}  (достигнута максимальная глубина анализа)")
            return

        if package in visited:
            print(f"{indent}  (циклическая ссылка)")
            return

        visited.add(package)

        for dep in self.graph.get(package, []):
            self.print_ascii_tree(dep, depth + 1, visited)

        visited.remove(package)

    def get_all_dependencies_recursive(self, package: str, visited: Set[str]) -> Set[str]:
        """Получить все транзитивные зависимости пакета"""
        if package not in self.graph:
            return set()
        if package in visited:
            return set()

        visited.add(package)
        result = {package}
        for dep in self.graph[package]:
            result.update(self.get_all_dependencies_recursive(dep, visited))
        return result

    def topological_sort(self, nodes: Set[str]) -> List[str]:
        visited: Set[str] = set()
        result: List[str] = []

        def dfs_topo(node: str):
            if node in visited:
                return
            visited.add(node)
            for dep in self.graph.get(node, []):
                if dep in nodes:
                    dfs_topo(dep)
            result.append(node)

        for node in nodes:
            if node not in visited:
                dfs_topo(node)

        return result

    def print_load_order(self, package: str):
        all_deps = self.get_all_dependencies_recursive(package, set())
        if package not in all_deps:
            all_deps.add(package)

        try:
            order = self.topological_sort(all_deps)
            print("\n   Порядок загрузки зависимостей")
            for i, pkg in enumerate(order, 1):
                print(f"{i}. {pkg}")
        except Exception as e:
            print(f"[ОШИБКА при топологической сортировке]: {e}")


def main():
    try:
        cfg = Config()
        cfg.load()
        cfg.display()
    except Exception as e:
        print(f"[ОШИБКА] {e}")
        sys.exit(1)

    graph = DependencyGraph(cfg.max_depth)

    if cfg.mode == "test":
        print("Режим тестирования: загрузка графа из локального файла\n")
        try:
            graph.load_from_test_file(cfg.repository_path)
        except Exception as e:
            print(f"[ОШИБКА] {e}")
            sys.exit(1)
    elif cfg.mode == "load_order":
        print("Режим вывода порядка загрузки зависимостей\n")
        try:
            graph.load_from_test_file(cfg.repository_path)
        except Exception as e:
            print(f"[ОШИБКА] {e}")
            sys.exit(1)

        graph.print_load_order(cfg.package_name)

        
        return
    else:
        print(f"Неизвестный режим: {cfg.mode}")
        sys.exit(1)

    visited: Set[str] = set()
    stack: Set[str] = set()
    result: List[Tuple[str, str]] = []

    print(f"Начало анализа зависимостей для пакета '{cfg.package_name}' (max_depth={cfg.max_depth})\n")
    graph.dfs(cfg.package_name, 0, visited, stack, result)

    print("\n   ASCII-дерево зависимостей")
    graph.print_ascii_tree(cfg.package_name)

    print("\n   Результаты анализа")
    print(f"Всего пакетов в тестовом репозитории: {len(graph.graph)}")
    print(f"Всего найдено связей (pkg → dep): {len(result)}")


if __name__ == "__main__":
    main()