import xml.etree.ElementTree as ET
import os
import sys
from urllib.parse import urlparse
import urllib.request
import tarfile
import io
import subprocess
import tempfile
from typing import Dict, List, Set, Tuple


class Config:
    def __init__(self, filename="config.xml"):
        self.filename = filename
        self.package_name = None
        self.repository_path = None
        self.mode = "test"
        self.max_depth = 3
        self.ascii_output = False  # новое поле для этапа 5

    def load(self):
        if not os.path.exists(self.filename):
            raise FileNotFoundError(f"Файл конфигурации '{self.filename}' не найден.")

        tree = ET.parse(self.filename)
        root = tree.getroot()

        self.package_name = (root.findtext("package_name") or "").strip()
        self.repository_path = (root.findtext("repository_url") or "").strip()
        self.mode = (root.findtext("mode") or "test").strip().lower()
        self.max_depth = int(root.findtext("max_depth") or "3")
        ascii_flag = (root.findtext("ascii_output") or "false").strip().lower()
        self.ascii_output = ascii_flag in ("true", "1", "yes")

        if not self.package_name:
            raise ValueError("Параметр 'package_name' не задан.")
        if not self.repository_path:
            raise ValueError("Параметр 'repository_url' (или путь к тестовому файлу) не указан.")
        if self.max_depth <= 0:
            raise ValueError("max_depth должен быть положительным числом.")

    def display(self):
        print("   Конфигурация ")
        print(f"Пакет: {self.package_name}")
        print(f"Репозиторий/Файл: {self.repository_path}")
        print(f"Режим: {self.mode}")
        print(f"Максимальная глубина: {self.max_depth}")
        if self.mode == "visualize":
            print(f"ASCII-вывод: {'включён' if self.ascii_output else 'отключён'}")


class DependencyGraph:
    def __init__(self, max_depth: int):
        self.graph: Dict[str, List[str]] = {}
        self.max_depth = max_depth

    def load_from_test_file(self, path: str):
        if not os.path.exists(path):
            raise FileNotFoundError(f"Файл тестового репозитория '{path}' не найден.")
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line or ":" not in line:
                    continue
                pkg, deps = line.split(":", 1)
                pkg = pkg.strip()
                dep_list = deps.strip().split() if deps.strip() else []
                self.graph[pkg] = dep_list

    def dfs(self, package: str, depth: int, visited: Set[str], stack: Set[str], result: List[Tuple[str, str]]):
        if depth >= self.max_depth:
            return
        if package not in self.graph:
            return

        stack.add(package)

        for dep in self.graph[package]:
            result.append((package, dep))
            if dep in stack:
                print(f"Цикл: {dep} уже встречен в пути ({' → '.join(stack)})")
                continue
            if dep not in visited:
                self.dfs(dep, depth + 1, visited, stack, result)

        stack.remove(package)
        visited.add(package)

    def print_ascii_tree(self, package: str, depth=0, visited=None):
        """Печать зависимостей в виде ASCII-дерева"""
        if visited is None:
            visited = set()

        indent = "  " * depth
        print(f"{indent}- {package}")

        if depth + 1 >= self.max_depth:
            if self.graph.get(package):
                print(f"{indent}  (достигнута максимальная глубина анализа)")
            return

        if package in visited:
            print(f"{indent}  (циклическая ссылка)")
            return

        visited.add(package)

        for dep in self.graph.get(package, []):
            self.print_ascii_tree(dep, depth + 1, visited)

        visited.remove(package)

    def get_all_dependencies_recursive(self, package: str, visited: Set[str]) -> Set[str]:
        """Получить все транзитивные зависимости пакета"""
        if package not in self.graph:
            return set()
        if package in visited:
            return set()

        visited.add(package)
        result = {package}
        for dep in self.graph[package]:
            result.update(self.get_all_dependencies_recursive(dep, visited))
        return result

    def topological_sort(self, nodes: Set[str]) -> List[str]:
        visited: Set[str] = set()
        result: List[str] = []

        def dfs_topo(node: str):
            if node in visited:
                return
            visited.add(node)
            for dep in self.graph.get(node, []):
                if dep in nodes:
                    dfs_topo(dep)
            result.append(node)

        for node in nodes:
            if node not in visited:
                dfs_topo(node)

        return result

    def print_load_order(self, package: str):
        all_deps = self.get_all_dependencies_recursive(package, set())
        if package not in all_deps:
            all_deps.add(package)

        try:
            order = self.topological_sort(all_deps)
            print("\n   Порядок загрузки зависимостей")
            for i, pkg in enumerate(order, 1):
                print(f"{i}. {pkg}")
        except Exception as e:
            print(f"[ОШИБКА при топологической сортировке]: {e}")

    def to_dot(self, root_package: str) -> str:
        if root_package not in self.graph:
            raise ValueError(f"Пакет '{root_package}' не найден в репозитории.")

        visited = set()
        edges = set()
        nodes = set()

        def collect(pkg):
            if pkg in visited or pkg not in self.graph:
                return
            visited.add(pkg)
            nodes.add(pkg)
            for dep in self.graph[pkg]:
                edges.add((pkg, dep))
                collect(dep)

        collect(root_package)

        lines = ["digraph G {", '    rankdir=TB;', '    node [shape=box, style=filled, fillcolor="#E6F2FF"];']
        for node in sorted(nodes):
            lines.append(f'    "{node}";')
        for src, dst in sorted(edges):
            lines.append(f'    "{src}" -> "{dst}";')
        lines.append("}")
        return "\n".join(lines)


def render_dot_and_show(dot_code: str, output_name: str = "graph"):
    with tempfile.NamedTemporaryFile(mode="w", suffix=".dot", delete=False) as f:
        f.write(dot_code)
        dot_path = f.name

    png_path = f"{output_name}.png"

    try:
        subprocess.run(["dot", "-Tpng", dot_path, "-o", png_path], check=True)
        print(f"\nГраф сохранён: {png_path}")

        if sys.platform == "win32":
            os.startfile(png_path)
        elif sys.platform == "darwin":
            subprocess.run(["open", png_path])
        else:
            subprocess.run(["xdg-open", png_path])
    except FileNotFoundError:
        print("\nGraphviz не найдена.")
        print("\nСгенерированный DOT-код:")
        print(dot_code)
    except subprocess.CalledProcessError as e:
        print(f"\nНе удалось сгенерировать изображение: {e}")
    finally:
        try:
            os.unlink(dot_path)
        except:
            pass


def main():
    try:
        cfg = Config()
        cfg.load()
        cfg.display()
    except Exception as e:
        print(f"[ОШИБКА] {e}")
        sys.exit(1)

    graph = DependencyGraph(cfg.max_depth)

    if cfg.mode == "test":
        print("Режим тестирования: загрузка графа из локального файла\n")
        try:
            graph.load_from_test_file(cfg.repository_path)
        except Exception as e:
            print(f"[ОШИБКА] {e}")
            sys.exit(1)

    elif cfg.mode == "load_order":
        print("Режим вывода порядка загрузки зависимостей\n")
        try:
            graph.load_from_test_file(cfg.repository_path)
        except Exception as e:
            print(f"[ОШИБКА] {e}")
            sys.exit(1)
        graph.print_load_order(cfg.package_name)
        return

    elif cfg.mode == "visualize":
        print("Режим визуализации: генерация графа зависимостей\n")
        try:
            graph.load_from_test_file(cfg.repository_path)
        except Exception as e:
            print(f"[ОШИБКА] {e}")
            sys.exit(1)

        if cfg.ascii_output:
            print("\n   ASCII-дерево зависимостей")
            graph.print_ascii_tree(cfg.package_name)
        try:
            dot_code = graph.to_dot(cfg.package_name)
            render_dot_and_show(dot_code, output_name=f"graph_{cfg.package_name}")
        except Exception as e:
            print(f"[ОШИБКА визуализации]: {e}")
            sys.exit(1)
        return

    else:
        print(f"Неизвестный режим: {cfg.mode}")
        sys.exit(1)

    # Для режима 'test' — стандартный анализ
    visited: Set[str] = set()
    stack: Set[str] = set()
    result: List[Tuple[str, str]] = []

    print(f"Начало анализа зависимостей для пакета '{cfg.package_name}' (max_depth={cfg.max_depth})\n")
    graph.dfs(cfg.package_name, 0, visited, stack, result)

    print("\n   ASCII-дерево зависимостей")
    graph.print_ascii_tree(cfg.package_name)

    print("\n   Результаты анализа")
    print(f"Всего пакетов в тестовом репозитории: {len(graph.graph)}")
    print(f"Всего найдено связей (pkg → dep): {len(result)}")


if __name__ == "__main__":
    main()